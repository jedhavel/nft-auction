package main

import (
	"cycoreutils"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric-chaincode-go/shim"
	"github.com/pkg/errors"
	logger "github.com/sirupsen/logrus"
)

type MetaData struct {
	name         string
	ipfsimage    string
	ipfsmetadata string
}

type Origin struct {
	blockchain string // bsc, bk, eth, bin
	creator    string // wallet address or hyperledger account
	quantity   string // amount originally made on the origin chain
}

type NftShare struct {
	shareHolder string // UserID, account
	quantity    string // shares owned
	aesKey      string // key
}

type NftObject struct {
	docType     string     `json:"docType"`
	nftId       string     `json:"nftId"`
	nftStatus   string     `json:"nftStatus"`
	name        string     `json:"name"`
	symbol      string     `json:"symbol"`
	itemId      string     `json:"itemID"`
	itemImage   string     `json:"itemImage"` // Image is encrypted with Owner's AESKey
	price       string     `json:"price"`     // Reserve Price at Auction must be greater than this price
	itemCpyNum  string     `json:"itemCpyNum"`
	owners      []NftShare // slice showing the ownership.
	bkCreator   NftShare   // NOTE: holds the info for the BK minting event, which may or may not be equal to the Origin
	TimeStamp   string     `json:"timeStamp"` // This is the time stamp
	ChainCodeId string     `json:"chainCodeId"`
	metaData    MetaData
	royalty     string
	origin      Origin // Original Creation Info
}

// TransferNft - Asset usied for transferring an NFT (Inventory)
type TransferNft struct {
	NftId          string `json:"nftId,required"`
	itemImage      string `json:"itemImage,required"`
	sender         string `json:"sender,required"`
	SenderAESKey   string `json:"senderAESKey,required"`   // This is generated by the AES Algorithms
	receiverAesKey string `json:"receiverAesKey,required"` // This is generated by the AES Algorithms
	receiver       string `json:"receiver,required"`
	ItemPrice      string `json:"itemPrice,required"`
	TimeStamp      string `json:"timeStamp"`
	quantity       string
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Record NFT to the ledger. This is equivalent to Mint
////////////////////////////////////////////////////////////////////////////////////////////////////////////
func recordNftObject(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {
	var err error
	var collectionName string
	var Avalbytes []byte
	var nftObject = &NftObject{} // make an empty NftObject

	// Convert the arg to a NftObject object
	logger.Info("recordNftObject() : Arguments for recordNftObject : ", args[0])
	err = cycoreutils.JSONtoObject([]byte(args[0]), nftObject) //Fill the empty NftObject with the data passed in arguments

	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY008E", fmt.Sprintf("Failed to convert arguments to a NFT object"), nil)
	}

	// Query and Retrieve the NFT
	keys := []string{nftObject.nftId}
	logger.Debug("Keys for NFT ${keys}: ")

	collectionName = ""

	Avalbytes, err = cycoreutils.QueryObject(stub, nftObject.docType, keys, collectionName)

	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY003E", (errors.Wrapf(err, "Failed to query NFT object")).Error(), nil)
	}

	if Avalbytes != nil {
		return cycoreutils.ConstructResponse("SASTQRY008E", fmt.Sprintf("NFT already exists"), nil)
	}

	// initialize the status of NFT
	nftObject.nftStatus = INITIAL

	// Record the NFT on the ledger
	nftObjectBytes, _ := cycoreutils.ObjecttoJSON(nftObject)
	err = cycoreutils.UpdateObject(stub, nftObject.docType, keys, nftObjectBytes, collectionName)

	if err != nil {
		logger.Errorf("recordNftObject() : Error inserting NFT object into LedgerState ${err}")
		return cycoreutils.ConstructResponse("SASTUPD009E", (errors.Wrapf(err, "NFT object update failed")).Error(), nil)
	}

	return cycoreutils.ConstructResponse("SASTREC011S", fmt.Sprintf("Successfully Recorded NFT object"), nftObjectBytes)
}

// transferNft - Transfer a quantity of NFT to new owner - no change in price
// ================================================================================
func transferNft(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {
	logger.Debug("Arguments for transferNft : ${args[0]}")

	transNft := &TransferNft{}
	err := cycoreutils.JSONtoObject([]byte(args[0]), transNft)

	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", (errors.Wrapf(err, "Failed to convert arguments to a TransferNft object")).Error(), nil)
	}

	collectionName := ""

	// Check if NFT exists
	nftBytes, err := cycoreutils.QueryObject(stub, NFT, []string{transNft.NftId}, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY003E", (errors.Wrapf(err, "Failed to query if NFT exists")).Error(), nil)
	}
	if nftBytes == nil {
		return cycoreutils.ConstructResponse("SASTDNE004E", fmt.Sprintf("NFT does not exist"), nil)
	}

	// Check if NFT is already on Auction by sender
	isNftOnAuction, err := verifyIfNftIsOnAuctionByUser(stub, transNft.NftId, transNft.sender)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY003E", fmt.Sprintf("Failed to check if NFT is on Auction"), nil)
	}
	if isNftOnAuction {
		return cycoreutils.ConstructResponse("SASTUPD009E", fmt.Sprintf("You have either initiated or opened for Auction this NFT!"), nil)
	}

	// Check if Sender is a valid user
	userBytes, err := cycoreutils.QueryObject(stub, USER, []string{transNft.sender}, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("CYUSRQRY003E", fmt.Sprintf("Failed to query if Seller exists"), nil)
	}
	if userBytes == nil {
		return cycoreutils.ConstructResponse("CYUSRDNE004E", fmt.Sprintf("Seller does not exist"), nil)
	}

	// Check if receiver is a valid user
	userBytes, err = cycoreutils.QueryObject(stub, USER, []string{transNft.receiver}, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("CYUSRQRY003E", fmt.Sprintf("Failed to query if receiver User exists"), nil)
	}
	if userBytes == nil {
		return cycoreutils.ConstructResponse("CYUSRDNE004E", fmt.Sprintf("receiver User does not exist"), nil)
	}

	// prevent self transfer
	if transNft.sender == transNft.receiver {
		return cycoreutils.ConstructResponse("SASTUPD009E", fmt.Sprintf("NFT cannot be Transferred. You are the already owner of the NFT"), nil)
	}

	senderIndex := -1

	// Check if nft ownership is valid.
	senderIndex, err = validateNftOwnership(stub, transNft.NftId, transNft.sender, transNft.SenderAESKey)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY008E", err.Error(), nil)
	}

	// Proceed with transfer
	nftObject := &NftObject{}
	err = cycoreutils.JSONtoObject(nftBytes, nftObject) // fill the nftObject
	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", fmt.Sprintf("NFT object unmarshalling failed"), nil)
	}

	receiverIndex := -1

	receiverIndex, err = validateNftOwnership(stub, transNft.NftId, transNft.receiver, transNft.receiverAesKey)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY008E", err.Error(), nil)
	}

	if senderIndex >= 0 { // then the receiver already has some of them
		nftObject.nftStatus = INITIAL
		nftObject.owners[receiverIndex].aesKey = transNft.receiverAesKey
		nftObject.itemImage = transNft.itemImage //TODO Why?
		nftObject.owners[receiverIndex].shareHolder = transNft.receiver
		nftObject.owners[receiverIndex].quantity = stringAdd(nftObject.owners[receiverIndex].quantity, transNft.quantity)
	} else { // new nftShare record
		nftObject.owners = append(nftObject.owners, NftShare{transNft.receiver, transNft.quantity, transNft.receiverAesKey})
	}

	//interpolate with negative sign to subtract
	nftObject.owners[senderIndex].quantity = stringAdd(nftObject.owners[senderIndex].quantity, "-${transNft.quantity}")

	if transNft.ItemPrice != "" {
		nftObject.price = transNft.ItemPrice // On transfer, the price is updated to whatever the cost was that was paid
	}

	nftBytes, err = cycoreutils.ObjecttoJSON(nftObject)                                            // nftBytes is byte rep of the JSON now
	err = cycoreutils.UpdateObject(stub, NFT, []string{nftObject.nftId}, nftBytes, collectionName) // here is the recording
	if err != nil {
		return cycoreutils.ConstructResponse("SASTUPD009E", fmt.Sprintf("Unable to transfer NFT"), nil)
	}

	return cycoreutils.ConstructResponse("SASTUPD010S", fmt.Sprintf("Successfully transferred Nft"), nftBytes)
}

// TODO move stringAdd() and `import strconv` to seperate oresys package and use arbitrary num of args
func stringAdd(str1 string, str2 string) string {
	n1, _ := strconv.Atoi(str1)
	n2, _ := strconv.Atoi(str2)
	return strconv.Itoa(n1 + n2)
}

// TODO move the sale and auction functions onto the cc

//////////////////////////////////////////////////////////////
/// Query Nft Info from the ledger
//////////////////////////////////////////////////////////////
func queryNftObject(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {

	var err error
	var Avalbytes []byte
	var collectionName string
	var nftObject = &NftObject{}

	// In future , it should be > 1 and ,= mo_of_keys for object
	if len(args) != 1 {
		return cycoreutils.ConstructResponse("SUSRPARM001E", fmt.Sprintf("Expecting NFT ID}. Received %d arguments", len(args)), nil)
	}

	nftObject.docType = "NFT"

	err = cycoreutils.JSONtoObject([]byte(args[0]), nftObject)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", (errors.Wrap(err, "Failed to convert arg[0] to NftObject object")).Error(), nil)
	}

	// Query and Retrieve the Full NftObject
	keys := []string{nftObject.nftId}
	logger.Info("Keys for NFT : ", keys)

	collectionName = ""

	Avalbytes, err = cycoreutils.QueryObject(stub, nftObject.docType, keys, collectionName)

	if err != nil {
		cycoreutils.ConstructResponse("SASTQRY003E", (errors.Wrapf(err, "Failed to query NFT object")).Error(), nil)
	}

	if Avalbytes == nil {
		return cycoreutils.ConstructResponse("SASTDNE004E", fmt.Sprintf("NFT not found"), nil)
	}

	err = cycoreutils.JSONtoObject(Avalbytes, nftObject)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", (errors.Wrapf(err, "Failed to convert query result to NFT object")).Error(), nil)
	}

	logger.Info("queryNftObject() : Returning NFT results")

	return cycoreutils.ConstructResponse("SASTQRY005S", fmt.Sprintf("Successfully Queried NFT object"), Avalbytes)
}

//////////////////////////////////////////////////////////////
/// Query List of Nfts by ItemID from the ledger
//////////////////////////////////////////////////////////////
func queryNftListByItemId(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {

	var collectionName string
	collectionName = ""

	logger.Info("Arguments for queryNftListByUser : ${args[0]}")

	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"NFT\",\"itemID\": \"%s\"}}", args[0])
	logger.Info("Query List: queryString: ", queryString)

	queryResults, err := cycoreutils.GetQueryResultForQueryString(stub, queryString, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY006E", (errors.Wrapf(err, "Failed to query NFT object list")).Error(), nil)
	}

	if queryResults == nil {
		return cycoreutils.ConstructResponse("SASTDNE004E", fmt.Sprintf("No Nfts found"), nil)
	}

	return cycoreutils.ConstructResponse("SASTQRY007S", fmt.Sprintf("Successfully Retrieved the list of NFT objects "), queryResults)
}

//////////////////////////////////////////////////////////////
/// Query list of Nfts owned by a user from the ledger
//////////////////////////////////////////////////////////////
func queryNftListByUser(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {
	collectionName := ""
	logger.Info("Arguments for queryNftListByUser : ${args[0]}")

	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"NFT\",\"owner\": \"%s\"}}", args[0])
	logger.Info("Query List: queryString: ", queryString)

	queryResults, err := cycoreutils.GetQueryResultForQueryString(stub, queryString, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY006E", (errors.Wrapf(err, "Failed to query NFT object list")).Error(), nil)
	}

	return cycoreutils.ConstructResponse("SASTQRY007S", fmt.Sprintf("Successfully Retrieved the list of NFT objects "), queryResults)
}

//////////////////////////////////////////////////////////////
/// Query NFT History from the ledger
//////////////////////////////////////////////////////////////
func queryNftObjectHistory(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {
	var err error
	var Avalbytes []byte
	var NftObject = &NftObject{}

	if len(args) != 1 {
		return cycoreutils.ConstructResponse("SUSRPARM001E", fmt.Sprintf("Expecting NFT ID}. Received %d arguments", len(args)), nil)
	}

	err = cycoreutils.JSONtoObject([]byte(args[0]), NftObject)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", (errors.Wrapf(err, "Failed to convert arg[0] to NFT object")).Error(), nil)
	}

	// Query and Retrieve the Full NFT
	keys := []string{NftObject.nftId}
	logger.Info("Keys for NFT : ", keys)

	Avalbytes, err = cycoreutils.GetObjectHistory(stub, "NFT", keys)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY003E", (errors.Wrapf(err, "Failed to query NFT object history")).Error(), nil)
	}
	if Avalbytes == nil {
		return cycoreutils.ConstructResponse("SASTDNE004E", fmt.Sprintf("NFT object not found"), nil)
	}

	return cycoreutils.ConstructResponse("SASTQRY014S", fmt.Sprintf("Successfully Queried NFT object History"), Avalbytes)
}

// This is a helper function
// validateNftOwnership - Validates The Ownership of an Asset using
// NFT ID, Owner ID, and AES Key
// ======================================================================================
func validateNftOwnership(stub shim.ChaincodeStubInterface, nftId string, owner string, AESKey string) (int, error) {
	collectionName := ""
	index := -1

	// query the NFT object by NftId
	nftBytes, err := cycoreutils.QueryObject(stub, NFT, []string{nftId}, collectionName)
	if err != nil {
		return index, fmt.Errorf("Failed to query if NFT exists")
	}
	if nftBytes == nil {
		return index, fmt.Errorf("NFT does not exist")
	}

	// unmarshal the NFT object if it exists
	nftObject := &NftObject{}
	err = cycoreutils.JSONtoObject(nftBytes, nftObject)
	if err != nil {
		return index, fmt.Errorf("Failed to unmarshal NFT object")
	}

	// ***** Note: un-comment these logs only during debugging *****
	// logger.Debug("NFT Secret Key is : " + string(NftObject.AESKey))
	// logger.Debug("Supplied Secret Key is : " + string(AESKey))

	// TODO - consider removing AES key validation
	// jonah 20220422 Keep the AES Validation in case someone gets in our network
	keyValidated := false
	for i := range nftObject.owners {
		if nftObject.owners[i].aesKey == AESKey {
			keyValidated = true
			index = i
			logger.Debug("NFT Owner ID : " + string(nftObject.owners[i].shareHolder))
			logger.Debug("Supplied Owner ID is : " + string(owner))
		}
	}
	if !keyValidated {
		return index, fmt.Errorf("Failed validating item ownership. NFT AES Key does not match supplied AES Key")
	}

	idValidated := false
	for i, o := range nftObject.owners {
		if o.shareHolder == owner {
			index = i
			idValidated = true
		}
	}
	if !idValidated {
		return index, fmt.Errorf("Failed validating item ownership. NFT Owner ID does not match supplied Seller ID")
	}
	return index, nil
}

// *************************************************************************************************************//
// Note: The methods below are not used as of now, but can be used to extend the functionality of the application
// *************************************************************************************************************//

//////////////////////////////////////////////////////////////
/// Query All NFTs from the ledger
//////////////////////////////////////////////////////////////
func queryNftObjectList(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {

	var collectionName string
	collectionName = ""

	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"NFT\"}}")
	logger.Info("Query List: queryString: ", queryString)

	queryResults, err := cycoreutils.GetQueryResultForQueryString(stub, queryString, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTQRY006E", (errors.Wrapf(err, "Failed to query NFT object list")).Error(), nil)
	}

	if queryResults == nil {
		return cycoreutils.ConstructResponse("SASTDNE004E", fmt.Sprintf("No Nfts found"), nil)
	}

	return cycoreutils.ConstructResponse("SASTQRY007S", fmt.Sprintf("Successfully Retrieved the list of NFT objects "), queryResults)
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Delete NFT from the ledger.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
func deleteNftObject(stub shim.ChaincodeStubInterface, args []string) cycoreutils.Response {

	var err error
	docType := "NFT"
	var collectionName string
	var NftObject = &NftObject{}

	collectionName = ""

	if len(args) != 1 {
		return cycoreutils.ConstructResponse("SUSRPARM001E", fmt.Sprintf("Expecting NFT ID}. Received %d arguments", len(args)), nil)
	}
	// Convert the arg to a deleteNftObject object
	logger.Info("deleteNftObject() : Arguments for Query: NFT : ", args[0])
	err = cycoreutils.JSONtoObject([]byte(args[0]), NftObject)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTCONV002E", (errors.Wrapf(err, "Failed to convert arg[0] to NFT object")).Error(), nil)
	}

	// Query and Retrieve the Full deleteNftObject
	keys := []string{NftObject.nftId}
	logger.Info("Keys for NFT : ", keys)

	err = cycoreutils.DeleteObject(stub, docType, keys, collectionName)
	if err != nil {
		return cycoreutils.ConstructResponse("SASTDEL012E", (errors.Wrapf(err, "Failed to delete NFT object")).Error(), nil)
	}

	return cycoreutils.ConstructResponse("SASTDEL013I", fmt.Sprintf("Successfully Deleted NFT object"), nil)
}

// getNftObject returns NFT object if found
func getNftObject(stub shim.ChaincodeStubInterface, nftId string) (*NftObject, error) {
	collectionName := ""
	// query the NFT object by NftId
	NftBytes, err := cycoreutils.QueryObject(stub, NFT, []string{nftId}, collectionName)
	if err != nil {
		return nil, fmt.Errorf("Failed to query if NFT exists")
	}
	if NftBytes == nil {
		return nil, fmt.Errorf("NFT does not exist")
	}

	// unmarshal the NFT object if it exists
	NftObject := &NftObject{}
	err = cycoreutils.JSONtoObject(NftBytes, NftObject)
	if err != nil {
		return nil, fmt.Errorf("Failed to unmarshal NFT object")
	}
	return NftObject, nil
}
